{"remainingRequest":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/node_modules/vue-loader-v16/dist/index.js??ref--0-1!/Users/berkaykosebay/Documents/GitHub/DBL-Project/src/views/fileUpload.vue?vue&type=style&index=0&id=94609c92&scoped=true&lang=css","dependencies":[{"path":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/src/views/fileUpload.vue","mtime":1621541108790},{"path":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/node_modules/vue-loader-v16/dist/stylePostLoader.js","mtime":1616796459000},{"path":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/node_modules/vue-loader-v16/dist/index.js","mtime":1616796459000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiAgdWx7CiAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7CiAgfQogIC5lZGdlcyBsaW5lIHsKICAgICAgc3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7CiAgICAgIHN0cm9rZS1vcGFjaXR5OiAwLjY7CiAgICB9CgogICAgLm5vZGVzIGNpcmNsZSB7CiAgICAgIHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOwogICAgICBzdHJva2Utd2lkdGg6IDEuNXB4OwogICAgfQogICAgLnJvdyB7CiAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICB9CiAgICAuY29sdW1uIHsKICAgICAgZmxleDogNTAlOwogICAgfQo="},{"version":3,"sources":["/Users/berkaykosebay/Documents/GitHub/DBL-Project/src/views/fileUpload.vue"],"names":[],"mappings":";EA0TE,CAAC,CAAC;IACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACvB;EACA,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;MACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACrB;;IAEA,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MACZ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACrB;IACA,CAAC,CAAC,CAAC,EAAE;MACH,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACf;IACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MACN,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACX","file":"/Users/berkaykosebay/Documents/GitHub/DBL-Project/src/views/fileUpload.vue","sourceRoot":"","sourcesContent":["<template>\n  <div class=\"fileupload\" v-bind:style=\"{display:grid}\">\n    <h1>File Upload Page</h1>\n    <input type=\"text\" placeholder=\"Name of the Dataset\" v-model=datasets.dataName class=\"form-control\">\n    <p id=\"msg\"></p><br><br>\n    <input type=\"file\" accept=\".csv\" @change=\"selectFile\"><button @click=\"uploadFile\">Upload</button><br><br>\n  </div><br><br>\n  <div class=\"row\">\n  <ul id=\"list\" class=\"column\"> </ul>\n  <div id=\"vis\" class=\"column\"></div>\n  </div>\n</template>\n\n<script>\nimport firebase from 'firebase';\nimport * as d3 from 'd3';\nimport {db} from '../main'\n\nexport default {\n  name: 'fileUpload',\n  data () {\n      return {\n        datasets: {\n          fileLink: null,\n          dataName: null,\n        },\n          selectedFile: null,\n          datasetNo: 0\n      }\n  },\n  mounted() {\n    this.getAllDatabaseEntries(); //the mounted() lifecycle executes after all components of the page have finished loading, so after the page is ready\n                                  // the previous uploaded datasets are visible in the page.\n  },\n  methods: {\n      selectFile(event) {\n          this.selectedFile = event.target.files[0] //Selects the uploaded file and assigns it to the \"selectedFile\" variable.\n          //TODO: Add proper checks to ensure that the files given are csv files.\n      },\n      uploadFile() {\n          let fileName = `${this.selectedFile.name}`;\n          var storageRef = firebase.storage().ref(fileName);\n          let uploadTask = storageRef.put(this.selectedFile);\n          uploadTask.on('state_changed', () => {\n          }, (error) => {\n            //Handle unsuccessfull uploads.\n            console.log(error);\n          }, () => {\n            //Handle successfull uploads.\n            uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {\n              this.datasets.fileLink = downloadURL;\n              this.saveDataToDB();\n            })\n          })\n          },\n      saveDataToDB() {\n          db.collection(\"datasets\").add(this.datasets).then((docRef) => {\n            var sucMsg = document.getElementById(\"msg\")\n            sucMsg.innerHTML = \"The dataset has been uploaded successfully.\"\n            console.log(\"Document written with ID: \", docRef.id);\n          })\n          .catch( (error) => {\n            console.error(\"Error adding document: \", error);\n          })\n          },\n      showDatabaseEntries(name, link) {\n          var ul = document.getElementById('list');\n          var header = document.createElement('h2');\n          var _name = document.createElement('li');\n          var _visualise = document.createElement('button');\n          var visDiv = document.getElementById('vis');\n         // var testParaghraph = document.createElement(\"h2\");\n          header.innerHTML = \"Dataset-\"+ (++this.datasetNo);\n          _name.innerHTML=\"Name of the dataset: \"+name;\n          _visualise.innerHTML = \"Visualise\";\n          _visualise.onclick = async () => {\n            visDiv.innerHTML=\"\";\n            const response = await fetch(link);\n            const data = d3.csvParse(await response.text(), d3.autoType);\n            var edges = [];\n            var nodes = [];\n            //console.log(data);\n            data.forEach((x) => {\n              var objEdges = {}\n              objEdges[\"source\"] = x.fromId;\n              objEdges[\"target\"] = x.toId;\n              edges.push(objEdges);\n              var objNodesTo = {}\n              var objNodesFrom = {}\n              var index = nodes.findIndex(o => o.employeeID == x.fromId)\n              if(index === -1) {\n                objNodesFrom[\"employeeID\"] = x.fromId;\n                nodes.push(objNodesFrom);\n              }\n              var index2 = nodes.findIndex(o => o.employeeID == x.toId)\n              if(index2 === -1) {\n                objNodesTo[\"employeeID\"] = x.toId;\n                nodes.push(objNodesTo);\n              }\n            })\n            console.log(edges);\n            console.log(nodes);\n            this.generateNetwork(edges, nodes);\n          }\n          ul.appendChild(header);\n          ul.appendChild(_name);\n          ul.appendChild(_visualise);\n        },\n      getAllDatabaseEntries() {\n          db.collection('datasets').get().then((snapshot) => {\n            snapshot.forEach((doc) => {\n              let name = doc.data().dataName;\n              let link = doc.data().fileLink;\n              this.showDatabaseEntries(name, link);\n            }\n            )\n          }\n          )\n        },\n    generateNetwork(edges, nodes) {\n      var w = 1000;\n      var h = 600;\n\n      var svg = d3\n        .select(\"#vis\")\n        .append(\"svg\")\n        .attr(\"width\", w)\n        .attr(\"height\", h)\n        .style(\"background\", \"black\")\n        .call(d3.zoom().on('zoom', (event) => {\n            svg.attr('transform', event.transform).scaleExtent([1,24]);}))\n        .append('g');\n      \n      var simulation = d3.forceSimulation(nodes)\n          .force(\"charge\", d3.forceManyBody().strength(-50))\n          .force(\"link\", d3.forceLink().id(function (d) {return d.employeeID;}).links(edges))\n          .force(\"center\", d3.forceCenter(w / 2, h / 2))\n          .on(\"end\", ticked);\n\n        var edge = svg\n          .append(\"g\")\n          .attr(\"class\", \"links\")\n          .selectAll(\"line\")\n          .data(edges)\n          .enter()\n          .append(\"line\")\n          .style(\"stroke\", \"#aaa\");\n\n        var node = svg\n          .append(\"g\")\n          .attr(\"class\", \"nodes\")\n          .selectAll(\"circle\")\n          .data(nodes)\n          .join(\"circle\")\n          .attr(\"r\", 5)\n          .attr(\"fill\", function() {return \"blue\";})\n          //.call(dragNodes(simulation));\n        \n        function ticked() {\n          edge\n            .attr(\"x1\", function(d) {\n              return d.source.x;\n            })\n            .attr(\"y1\", function(d) {\n              return d.source.y;\n            })\n            .attr(\"x2\", function(d) {\n              return d.target.x;\n            })\n            .attr(\"y2\", function(d) {\n              return d.target.y;\n            });\n            \n            node\n              .attr(\"cx\", function(d) {\n              return d.x;\n            })\n              .attr(\"cy\", function(d) {\n              return d.y;\n            });\n        }\n        /*function dragNodes(simulation) { // This needs a lot more optimization, so it is being left out for the prototype.\n          function dragStarted(event) {\n            if (!event.active) simulation.alphaTarget(0.3).restart();\n            event.subject.fx = event.subject.x;\n            event.subject.fy = event.subject.y;\n          }\n          \n          function dragged(event) {\n            event.subject.fx = event.x;\n            event.subject.fy = event.y;\n          }\n          \n          function dragEnded(event) {\n            if (!event.active) simulation.alphaTarget(0);\n            event.subject.fx = null;\n            event.subject.fy = null;\n          }\n          \n          return d3.drag()\n              .on(\"start\", dragStarted)\n              .on(\"drag\", dragged)\n              .on(\"end\", dragEnded);\n        }*/\n      console.log(simulation)\n      return svg.node();\n}\n/*generateNetworkWithCanvas(edges, nodes) { //Trying to optimize by using a canvas instead of svg, should improve performance of the full dataset quite a bit, but just testing atm. Not included in the prototype.\n      var w = 1000;\n      var h = 600;\n      var r = 5;\n\n      var htmlCanvas = d3\n        .select(\"#vis\")\n        .append(\"canvas\")\n        .attr(\"width\", w)\n        .attr(\"height\", h)\n        .style(\"background\", \"black\");\n      \n      var canvasToolbox = htmlCanvas.node().getContext('2d'); //Canvas toolbox, it is an object carrying all the properties and methods we need to draw on the canvas.\n      \n      //var div = d3.select(\"body\").append(\"div\").attr(\"class\", \"tooltip\").style(\"opacity\", 0);\n      \n      var simulation = d3.forceSimulation(nodes)\n          .force(\"charge\", d3.forceManyBody().strength(-30))\n          .force(\"x\", d3.forceX(w / 2).strength(0.1))\n          .force(\"y\", d3.forceY(h / 2).strength(0.1))\n          .force(\"link\", d3.forceLink().id(function (d) {return d.employeeID;}).links(edges))\n          .force(\"center\", d3.forceCenter(w / 2, h / 2));\n      \n      var transform = d3.zoomIdentity;\n\n      initGraph(edges, nodes);\n\n      function initGraph(edges, nodes) {\n        \n        function zoomed(event) {\n          console.log(\"zooming\");\n          transform = event.transform;\n          ticked()\n        }\n        console.log(\"Hello\")\n        d3.select(htmlCanvas)\n            .call(d3.drag().subject(dragsubject).on(\"start\", dragStarted).on(\"drag\", dragged).on(\"end\",dragEnded))\n            .call(d3.zoom().scaleExtent([1 / 10, 8]).on(\"zoom\", zoomed));\n        \n        function dragsubject(event) {\n          var i,\n          x = transform.invertX(event.x),\n          y = transform.invertY(event.y),\n          dx,\n          dy;\n          for (i = nodes.length - 1; i >= 0; --i) {\n            var node = nodes[i];\n            dx = x - node.x;\n            dy = y - node.y;\n\n            if (dx * dx + dy * dy < r * r) {\n\n              node.x =  transform.applyX(node.x);\n              node.y = transform.applyY(node.y);\n\n              return node;\n            }\n          }\n        }\n        function dragStarted(event) {\n            if (!event.active) simulation.alphaTarget(0.3).restart();\n            event.subject.fx = event.subject.x;\n            event.subject.fy = event.subject.y;\n          }\n          \n          function dragged(event) {\n            event.subject.fx = event.x;\n            event.subject.fy = event.y;\n          }\n          \n          function dragEnded(event) {\n            if (!event.active) simulation.alphaTarget(0);\n            event.subject.fx = null;\n            event.subject.fy = null;\n          }\n          simulation.nodes(nodes).on('tick', ticked);\n          simulation.force(\"link\").links(edges);\n          \n          function ticked() {\n          canvasToolbox.save();\n          canvasToolbox.clearRect(0, 0, w, h);\n          canvasToolbox.translate(transform.x, transform.y);\n          canvasToolbox.scale(transform.k, transform.k);\n\n          edges.forEach(function (d) {\n            canvasToolbox.beginPath();\n            canvasToolbox.moveTo(d.source.x, d.source.y);\n            canvasToolbox.lineTo(d.target.x, d.target.y);\n            canvasToolbox.stroke();\n          });\n          nodes.forEach(function (d) {\n            canvasToolbox.beginPath();\n            canvasToolbox.arc(d.x, d.y, r, 0, 2 * Math.PI, true);\n            canvasToolbox.fillStyle = d.col ? \"red\":\"black\"\n            canvasToolbox.fill();\n          });\n          canvasToolbox.restore();\n        }\n\n      }\n}*/\n}\n}\n\n\n</script>\n<style scoped>\n  ul{\n    list-style-type: none;\n  }\n  .edges line {\n      stroke: rgb(255, 255, 255);\n      stroke-opacity: 0.6;\n    }\n\n    .nodes circle {\n      stroke: rgb(255, 255, 255);\n      stroke-width: 1.5px;\n    }\n    .row {\n      display: flex;\n    }\n    .column {\n      flex: 50%;\n    }\n</style>"]}]}